/*
 * QALIPSIS
 * Copyright (C) 2023 AERIS IT Solutions GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package io.qalipsis.core.head.inmemory.consolereporter

import io.qalipsis.api.context.CampaignKey
import io.qalipsis.api.context.ScenarioName
import io.qalipsis.api.context.StepName
import io.qalipsis.api.report.ExecutionStatus
import io.qalipsis.api.report.ReportMessageSeverity
import java.time.Duration
import java.time.Instant
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference

/**
 * Overall state of a running campaign to report.
 */
data class CampaignState(val campaignKey: CampaignKey) {

    val scenarios = ConcurrentHashMap<ScenarioName, ScenarioState>()

    val progressionState = ProgressionState()

    val start = AtomicReference<Instant>()

    val end = AtomicReference<Instant>()

    val timeout = AtomicReference<Instant>()

    val campaignText: String
        get() = "Campaign: $campaignKey"

    val scenariosListText: String
        get() = if (scenarios.size > 1) {
            "Scenario(s): ${scenarios.keys.sorted().joinToString()}"
        } else {
            "Scenario: ${scenarios.keys.firstOrNull() ?: "<Unknown>"}"
        }

    val startText: String
        get() = "Start: ${start.get().serialize()}"

    val endText: String
        get() = if (end.get() != null) {
            "End: ${end.get().serialize()}"
        } else {
            "Timeout: ${timeout.get()?.serialize() ?: "<Undefined>"}"
        }

    val durationText: String
        get() {
            val end = end.get() ?: Instant.now()
            val duration = Duration.between(start.get(), end)
            return "Elapsed: ${duration.serialize()}"
        }
}

/**
 * Progression indicator of a running campaign or scenario.
 */
class ProgressionState {

    val state = AtomicReference(ExecutionStatus.IN_PROGRESS)

    val scheduledMinions = AtomicInteger(0)

    val startedMinions = AtomicInteger(0)

    val completedMinions = AtomicInteger(0)

    val successfulSteps = AtomicInteger(0)

    val failedSteps = AtomicInteger(0)

}

/**
 * Overall state of a running scenario.
 */
data class ScenarioState(val scenarioName: ScenarioName) {

    val progressionState = ProgressionState()

    val failedInitialization = AtomicBoolean(false)

    val end = AtomicReference<Instant>()

    val stepInitializationOrder = mutableListOf<StepName>()

    val steps = ConcurrentHashMap(LinkedHashMap<StepName, StepState>())

    val errorsByType = ConcurrentHashMap<Class<out Throwable>, AtomicInteger>()

    val messages = mutableListOf<ExecutionMessage>()

    /**
     * Number of current errors, to drive the status of the scenario.
     */
    val reportableErrors = AtomicInteger()

    /**
     * Number of current warnings, to drive the status of the scenario.
     */
    val reportableWarnings = AtomicInteger()

    val endText: String?
        get() = if (end.get() != null) "End: ${end.get().serialize()}" else null
}

/**
 * Overall state of a single step involved in a running scenario.
 */
data class StepState(val stepName: StepName) {

    val failedInitialization = AtomicBoolean(false)

    val successfulExecutions = AtomicInteger(0)

    val failedExecutions = AtomicInteger(0)

    val messages = ConcurrentHashMap<String, ExecutionMessage>()

    val errorsByType = ConcurrentHashMap<Class<out Throwable>, AtomicInteger>()

}

/**
 * Message generated by a running scenario or step.
 */
data class ExecutionMessage(val id: String, val severity: ReportMessageSeverity, val text: String)

/**
 * Provides a localized serialized string of the instant.
 */
private fun Instant.serialize(): String {
    return atZone(ZoneId.systemDefault()).truncatedTo(ChronoUnit.SECONDS).toLocalDateTime().toString()
}

/**
 * Provides a serialized string of the duration.
 */
private fun Duration.serialize(): String {
    var result = "${toSecondsPart()}".padStart(2, '0')
    result = "${toMinutesPart()}".padStart(2, '0') + ":$result"
    val hoursPart = toHoursPart()
    val daysPart = toDaysPart()

    if (hoursPart > 1) {
        result = "$hoursPart".padStart(2, '0') + ":$result"
    }
    if (daysPart > 1) {
        result = "$daysPart:$result"
    }
    return result
}