package io.qalipsis.core.head.jdbc.entity

import io.micronaut.core.annotation.Introspected
import io.micronaut.data.annotation.GeneratedValue
import io.micronaut.data.annotation.Id
import io.micronaut.data.annotation.MappedEntity
import io.micronaut.data.annotation.Transient
import io.micronaut.data.annotation.TypeDef
import io.micronaut.data.annotation.Version
import io.micronaut.data.model.naming.NamingStrategies
import io.qalipsis.api.report.query.QueryAggregationOperator
import io.qalipsis.api.report.query.QueryClauseOperator
import io.qalipsis.core.head.model.DataSeriesFilter
import io.qalipsis.core.head.report.DataType
import io.qalipsis.core.head.report.SharingMode
import java.time.Duration
import java.time.Instant
import javax.validation.Valid
import javax.validation.constraints.NotBlank
import javax.validation.constraints.NotNull
import javax.validation.constraints.Pattern
import javax.validation.constraints.Positive
import javax.validation.constraints.Size

/**
 * Details of a unique query for time-series data.
 *
 * @property id internal database ID
 * @property reference unique public key
 * @property version version of the entity
 * @property tenantId internal database ID of the tenant in which the entity was created
 * @property creatorId internal database ID of the user who create the series entity
 * @property displayName display name of the time series, should be unique into a tenant
 * @property sharingMode sharing mode with the other members of the tenant
 * @property dataType is a nature of data to fetch, corresponding to the different data types generated by tests: event or meter
 * @property color optional color to set as an hexa value
 * @property filters  set of filters (should at least contain ony filter)
 * @property fieldName optional name of the field to use from the event or meter (ex: duration, count)
 * @property aggregationOperation an aggregation operation to perform on the values pointed out by the field name,
 * in order to scale the values with the time
 * @property timeframeUnitMs duration to aggregate the values
 * @property displayFormat an optional display format to display the value, depending on its type
 * @property query prepared query to execute in the underlying data series provider, it should be generated by the underlying data series provider itself and saved as a valid JSON
 *
 * @author Palina Bril
 */
@MappedEntity("data_series", namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)
internal data class DataSeriesEntity(
    @field:Id
    @field:GeneratedValue(GeneratedValue.Type.SEQUENCE)
    override val id: Long,

    @field:NotBlank
    val reference: String,

    @field:Version
    val version: Instant,

    @field:NotNull
    val tenantId: Long,

    @field:NotNull
    val creatorId: Long,

    @field:NotBlank
    @field:Size(min = 1, max = 200)
    var displayName: String,

    @field:NotBlank
    var sharingMode: SharingMode = SharingMode.READONLY,

    @field:NotBlank
    val dataType: DataType,

    @field:Pattern(regexp = "^#[0-9a-fA-F]{6}$")
    @field:Size(max = 7)
    var color: String?,

    @field:TypeDef(type = io.micronaut.data.model.DataType.JSON)
    var filters: Collection<@Valid DataSeriesFilterEntity>,

    @field:Size(max = 60)
    var fieldName: String?,

    var aggregationOperation: QueryAggregationOperator,

    @field:Positive
    var timeframeUnitMs: Long?,

    @field:Size(max = 20)
    var displayFormat: String?,

    var query: String?

) : Entity {

    @get:Transient
    val timeframeUnitAsDuration: Duration?
        get() = timeframeUnitMs?.let(Duration::ofMillis)

    constructor(
        reference: String,
        tenantId: Long,
        creatorId: Long,
        displayName: String,
        sharingMode: SharingMode = SharingMode.READONLY,
        dataType: DataType,
        color: String? = null,
        filters: Collection<DataSeriesFilterEntity> = emptySet(),
        fieldName: String? = null,
        aggregationOperation: QueryAggregationOperator = QueryAggregationOperator.COUNT,
        timeframeUnitMs: Long? = null,
        displayFormat: String? = null,
        query: String? = null
    ) : this(
        id = -1,
        reference = reference,
        version = Instant.EPOCH,
        tenantId = tenantId,
        creatorId = creatorId,
        displayName = displayName,
        sharingMode = sharingMode,
        dataType = dataType,
        color = color,
        filters = filters,
        fieldName = fieldName,
        aggregationOperation = aggregationOperation,
        timeframeUnitMs = timeframeUnitMs,
        displayFormat = displayFormat,
        query = query
    )
}

/**
 * Filter to implement for fetching time-series
 * @property name of the field to apply the filter
 * @property operator one of: is, is not , is in, is not in
 * @property value can contain wildcards signs *
 *
 * @author Palina Bril
 */
@Introspected
internal data class DataSeriesFilterEntity(
    @field:NotBlank
    @field:Size(min = 1, max = 60)
    val name: String,

    val operator: QueryClauseOperator,

    @field:NotBlank
    @field:Size(min = 1, max = 200)
    val value: String
) {
    fun toModel(): DataSeriesFilter {
        return DataSeriesFilter(
            name = name,
            operator = operator,
            value = value
        )
    }
}