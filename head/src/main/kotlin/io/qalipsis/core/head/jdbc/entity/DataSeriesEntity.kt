/*
 * QALIPSIS
 * Copyright (C) 2022 AERIS IT Solutions GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package io.qalipsis.core.head.jdbc.entity

import io.micronaut.core.annotation.Introspected
import io.micronaut.data.annotation.GeneratedValue
import io.micronaut.data.annotation.Id
import io.micronaut.data.annotation.MappedEntity
import io.micronaut.data.annotation.Transient
import io.micronaut.data.annotation.TypeDef
import io.micronaut.data.annotation.Version
import io.micronaut.data.model.naming.NamingStrategies
import io.qalipsis.api.query.QueryAggregationOperator
import io.qalipsis.api.query.QueryClauseOperator
import io.qalipsis.core.head.model.DataSeries
import io.qalipsis.core.head.model.DataSeriesFilter
import io.qalipsis.core.head.report.DataType
import io.qalipsis.core.head.report.SharingMode
import java.time.Duration
import java.time.Instant
import javax.validation.Valid
import javax.validation.constraints.NotBlank
import javax.validation.constraints.NotNull
import javax.validation.constraints.Pattern
import javax.validation.constraints.Positive
import javax.validation.constraints.Size

/**
 * Details of a unique query for time-series data.
 *
 * @property id internal database ID
 * @property reference unique public key
 * @property version version of the entity
 * @property tenantId internal database ID of the tenant in which the entity was created
 * @property creatorId internal database ID of the user who create the series entity
 * @property displayName display name of the time series, should be unique into a tenant
 * @property sharingMode sharing mode with the other members of the tenant
 * @property dataType is a nature of data to fetch, corresponding to the different data types generated by tests: event or meter
 * @property valueName name of the event or meter to fetch
 * @property color optional color to set as an hexa value
 * @property filters  set of filters (can be empty)
 * @property fieldName optional name of the field to use from the event or meter (ex: duration, count)
 * @property aggregationOperation an aggregation operation to perform on the values pointed out by the field name,
 * in order to scale the values with the time
 * @property timeframeUnitMs duration to aggregate the values
 * @property displayFormat an optional display format to display the value, depending on its type
 * @property query prepared query to execute in the underlying data series provider, it should be generated by the underlying data series provider itself and saved as a valid JSON
 *
 * @author Palina Bril
 */
@MappedEntity("data_series", namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)
internal data class DataSeriesEntity(
    @field:Id
    @field:GeneratedValue(GeneratedValue.Type.SEQUENCE)
    override val id: Long,

    @field:NotBlank
    val reference: String,

    @field:Version
    val version: Instant,

    @field:NotNull
    val tenantId: Long,

    @field:NotNull
    val creatorId: Long,

    @field:NotBlank
    @field:Size(min = 1, max = 200)
    var displayName: String,

    @field:NotBlank
    var sharingMode: SharingMode = SharingMode.READONLY,

    val dataType: DataType,

    @field:NotBlank
    var valueName: String,

    @field:Pattern(regexp = "^#[0-9a-fA-F]{6}$")
    @field:Size(max = 7)
    var color: String?,

    @field:TypeDef(type = io.micronaut.data.model.DataType.JSON)
    var filters: Collection<@Valid DataSeriesFilterEntity>,

    @field:Size(max = 60)
    var fieldName: String?,

    var aggregationOperation: QueryAggregationOperator,

    @field:Positive
    var timeframeUnitMs: Long?,

    @field:Size(max = 20)
    var displayFormat: String?,

    var query: String?

) : Entity {

    @get:Transient
    val timeframeUnitAsDuration: Duration?
        get() = timeframeUnitMs?.let(Duration::ofMillis)

    constructor(
        reference: String,
        tenantId: Long,
        creatorId: Long,
        displayName: String,
        sharingMode: SharingMode = SharingMode.READONLY,
        dataType: DataType,
        valueName: String,
        color: String? = null,
        filters: Collection<DataSeriesFilterEntity> = emptySet(),
        fieldName: String? = null,
        aggregationOperation: QueryAggregationOperator = QueryAggregationOperator.COUNT,
        timeframeUnitMs: Long? = null,
        displayFormat: String? = null,
        query: String? = null
    ) : this(
        id = -1,
        reference = reference,
        version = Instant.EPOCH,
        tenantId = tenantId,
        creatorId = creatorId,
        displayName = displayName,
        sharingMode = sharingMode,
        dataType = dataType,
        valueName = valueName,
        color = color,
        filters = filters,
        fieldName = fieldName,
        aggregationOperation = aggregationOperation,
        timeframeUnitMs = timeframeUnitMs,
        displayFormat = displayFormat,
        query = query
    )

    fun toModel(creatorName : String) = DataSeries(this, creatorName)
}

/**
 * Filter to implement for fetching time-series
 * @property name of the field to apply the filter
 * @property operator one of: is, is not , is in, is not in
 * @property value can contain wildcards signs *
 *
 * @author Palina Bril
 */
@Introspected
internal data class DataSeriesFilterEntity(
    @field:NotBlank
    @field:Size(min = 1, max = 60)
    val name: String,

    val operator: QueryClauseOperator,

    @field:NotBlank
    @field:Size(min = 1, max = 200)
    val value: String
) {
    fun toModel(): DataSeriesFilter {
        return DataSeriesFilter(
            name = name,
            operator = operator,
            value = value
        )
    }
}