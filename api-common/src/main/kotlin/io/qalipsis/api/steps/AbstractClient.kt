/*
 * Copyright 2022 AERIS IT Solutions GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package io.qalipsis.api.steps

import io.qalipsis.api.context.StepContext
import io.qalipsis.api.sync.Slot

/**
 * Parent classes for reusable or polled clients.
 *
 * The implementations should continuously remove requests from the [request] slot and place the response
 * into the [response] slot, which is automatically returned to the output.
 *
 * When a context is required to configure the execution, it is placed into the [context] slot.
 *
 * [Slot] are used instead of [kotlinx.coroutines.channels.Channel]s to ensure that one response can be received
 * at a time from one request at the step layer (which might actually be different behind the scenes if the transport
 * protocol supports pipelining and multiplexing).
 *
 * @author Eric Jess√©
 *
 * @param RQ type of the requests generated by the client
 * @param RS type of the result received from the server
 * @param START_CTX type of the context used to start the client
 * @param CTX type of the context used to configure specific behaviors at execution time
 * @param STOP_CTX type of the context used to stop the client
 */
abstract class AbstractClient<RQ, RS, START_CTX : Any, CTX : Any, STOP_CTX : Any> {

    /**
     * Indicates if the client is open or closed.
     */
    abstract val isOpen: Boolean

    /**
     * Request for the client to receive the request to send.
     */
    protected val request = Slot<RQ>()

    /**
     * The client is single-threaded and can only receive one response at time.
     */
    protected val response = Slot<RS>()


    /**
     * Slot containing the context while being executed.
     */
    protected val context = Slot<CTX>()

    /**
     * Starts the consumption of [request].
     */
    abstract suspend fun open(startContext: START_CTX)

    /**
     * Stops the consumption of [request]. The method is idempotent: several calls lead to the same state.
     */
    abstract suspend fun close(stopContext: STOP_CTX)

    /**
     * Execution method for a client.
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun <I, O> execute(
        stepContext: StepContext<I, Pair<I, O>>, clientContext: CTX,
        requestBuilder: suspend (I) -> RQ = { it as RQ },
        responseBuilder: suspend (RS) -> O = { it as O }
    ) {
        try {
            context.set(clientContext)
            val input = stepContext.receive()
            request.set(requestBuilder(input))
            val response = response.get()
            stepContext.send(input to responseBuilder(response))
        } finally {
            request.clear()
            context.clear()
            response.clear()
        }
    }

}
