== Plugins

=== What is a plugin?
==== Introduction

A plugin is a technical extension designed to extend the core capabilities of the tools.

The plugin mechanism tackles the complexity implied by the multiplicity of technologies and use cases to support in the tool, and reduce the coupling between the technical elements, keeping them safer and easier to maintain.

The main advantages of a plugin strategy for extension are the drastic reduction of the weight of the required libraries to run a scenario and a better user / developer experience, letting them focus on what is absolutely relevant to them. Among other user / developer experience benefits, we can list smaller list of proposal when using auto-completion, faster compilation time, faster start time, smaller artefacts to store, transport and share.

By nature, a plugin is an optional component of the tool. You only include what you need, ignoring components and libraries that do not serve your needs your present critical concerns.

While a certain number of plugins are proposed by the community to cover the most common use cases and technologies, a plugin can also be an extension only for yourself and remain private.

==== What does a plugin can do?
A plugin contains one or several technical functionalities of the software, that are not part of the core. Or at least not as such. The most common functionalities a plugin might implement are:

* A step to perform actions, like:
** executing requests on an remote system using a specific protocol
** polling data from a source
** transforming data
* Events logger
* Metrics registry to a datastore
* Cache storage
* Messaging platform or protocol

All those functionalities are already implemented in the core with default implementations, which might not suit productive testing or constant monitoring. Plugins improve the coverage of the different technologies by providing related implementations.

==== How and when is a plugin integrated to my deployment?

To create a test scenario, a tiny Gradle/Maven project is required. The plugin is simply added as a dependency to the class path of the project. You can read more about it in the documentation to create a scenario.

If the development of a scenario requires the plugin to compile - like when using a step - the dependency to the plugin artefact has to be added to the implementation dependencies.

If the plugin delivers functionalities you only need at runtime, add it to the runtimeOnly dependencies.

In case of doubt, you can still add to the implementation dependencies - api if the relationship between the executable project and the dependency is transitive.

==== Do I always need a plugin?

While plugins provide best practices and a convention to perform recurrent operations, they might not be always necessary. One-time show case or simple actions do not require to develop a plugin: the source code you create and need is directly part of your scenario project source and packaged into the executable archive.

=== Use a QALIPSIS plugin

QALIPSIS provides a bunch of plugins targeting different technologies, systems and protocols.

To use a plugin, just add the related dependency to your project.

Gradle - Groovy DSL:
[source,groovy,subs="normal"]
----
implementation group:'io.qalipsis', name: 'plugin-XXX', version: '{revnumber}'
----

Gradle - Kotlin DSL:
[source,kotlin,subs="normal"]
----
implementation("io.qalipsis:plugin-XXX:{revnumber}")
----

Maven:
[source,xml,subs="normal"]
----
<dependency>
    <groupId>io.qalipsis</groupId>
    <artifactId>plugin-XXX</artifactId>
    <version>{revnumber}</version>
</dependency>
----

You can find the list of available plugins and their related documentation on the dedicated site.


=== Create your own plugin

TO DO