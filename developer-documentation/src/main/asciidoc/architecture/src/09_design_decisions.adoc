[[section-design-decisions]]
== Design Decisions

NOTE: This section will be enhanced while developing the solution

[role="arc42help"]
****
.Contents
Important, expensive, large scale or risky architecture decisions including rationals.
With "decisions" we mean selecting one alternative based on given criteria.

Please use your judgement to decide whether an architectural decision should be documented here in this central section or whether you better document it locally (e.g. within the white box template of one building block).

Avoid redundancy.
Refer to section 4, where you already captured the most important decisions of your architecture.

.Motivation
Stakeholders of your system should be able to comprehend and retrace your decisions.

.Form
Various options:

* List or table, ordered by importance and consequences or:
* more detailed in form of separate sections per decision
* ADR (architecture decision record) for every important decision
****

[options="header",cols="2,2,5"]
|===
| Topic                                 | Short version            | Long version
| Back-end programming language         | https://kotlinlang.org[Kotlin]            |
Java is one of the most used programming languages for a decade -> A lot of potential users.

JVM motto is "develop once, run anywhere" -> Simplifies and reduces the development effort.

Java ecosystem is extremely rich of open-source libraries -> Covers a wide range of technical and business use cases.

But Kotlin brings even more than Java -> Kotlin can use Java based byte code, native concurrency model, light threads and especially, Java drags its legacy (in 2020, lambdas cannot change external values, there is no Elvis operator, and Java is still very verbose for some basic operations). You can read more https://kotlinlang.org/docs/reference/comparison-to-java.html[here].

With Kotlin, the main drawback to deal with, will be the lack of primitive types, which could generate memory over use on a very high number of minions.


| Back-end Frameworks                           | https://netty.io[Netty HTTP server] for the head, Kapt for both for the IoC, https://github.com/classgraph/classgraph[Classgraph] for scenario discovery in the factories |
On one side, performance and lightweight are key features for the factories, thus it is important to keep them minimal without much overhead. Furthermore, the simplicity of the factories does not make it mandatory to orchestrate them via an external framework. However, an important point to be able to find the scenarios specifications in the classpath. In order to make it efficient,

On the other side, heads main technical requirements are user-experience, stability and security, while keeping good performances. Thus the minimalistic HTTP framework like Netty HTTP server should be enough to provide a safe HTTP server and data processing capabilities. Furthermore Netty is a very widely used and library, supported by all the major vendors and frameworks.

Finally, in order to reduce the coupling and improve code extensibility, an IoC framework has to be used. https://kotlinlang.org/docs/reference/kapt.html[Kapt] is the framework of choice for Kotlin and provides ahead-of-time injection.

| Front-end programming language                | https://www.typescriptlang.org[Typescript]       |
While Javascript is still evolving and provides always new fancy features, we consider Typescript as a next-generation evolution of Javascript for mid-sized software.

Keeping in mind our requirements for clean safe code and development velocity, we consider that Typescript is the good tool to meet them.

| Alternative technologies                   | GraalVM, Golang, Rust, Javascript?                |
Decoupling the head from the factories also aims at later integrating other technologies in Qalipsis. If GraalVM is first prospective to improve resources consumption of existing Kotlin code, the Qalipsis ecosystem is not constrained to only use JVM based technologies. We could absolutely think of creating factories in different languages to support more technical use cases and even reimplement the head to improve it.

|===
