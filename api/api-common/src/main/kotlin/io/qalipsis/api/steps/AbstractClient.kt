/*
 * QALIPSIS
 * Copyright (C) 2025 AERIS IT Solutions GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package io.qalipsis.api.steps

import io.qalipsis.api.context.StepContext
import io.qalipsis.api.sync.Slot

/**
 * Parent classes for reusable or polled clients.
 *
 * The implementations should continuously remove requests from the [request] slot and place the response
 * into the [response] slot, which is automatically returned to the output.
 *
 * When a context is required to configure the execution, it is placed into the [context] slot.
 *
 * [Slot] are used instead of [kotlinx.coroutines.channels.Channel]s to ensure that one response can be received
 * at a time from one request at the step layer (which might actually be different behind the scenes if the transport
 * protocol supports pipelining and multiplexing).
 *
 * @author Eric Jess√©
 *
 * @param RQ type of the requests generated by the client
 * @param RS type of the result received from the server
 * @param START_CTX type of the context used to start the client
 * @param CTX type of the context used to configure specific behaviors at execution time
 * @param STOP_CTX type of the context used to stop the client
 */
abstract class AbstractClient<RQ, RS, START_CTX : Any, CTX : Any, STOP_CTX : Any> {

    /**
     * Indicates if the client is open or closed.
     */
    abstract val isOpen: Boolean

    /**
     * Request for the client to receive the request to send.
     */
    protected val request = Slot<RQ>()

    /**
     * The client is single-threaded and can only receive one response at time.
     */
    protected val response = Slot<RS>()


    /**
     * Slot containing the context while being executed.
     */
    protected val context = Slot<CTX>()

    /**
     * Starts the consumption of [request].
     */
    abstract suspend fun open(startContext: START_CTX)

    /**
     * Stops the consumption of [request]. The method is idempotent: several calls lead to the same state.
     */
    abstract suspend fun close(stopContext: STOP_CTX)

    /**
     * Execution method for a client.
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun <I, O> execute(
        stepContext: StepContext<I, Pair<I, O>>, clientContext: CTX,
        requestBuilder: suspend (I) -> RQ = { it as RQ },
        responseBuilder: suspend (RS) -> O = { it as O }
    ) {
        try {
            context.set(clientContext)
            val input = stepContext.receive()
            request.set(requestBuilder(input))
            val response = response.get()
            stepContext.send(input to responseBuilder(response))
        } finally {
            request.clear()
            context.clear()
            response.clear()
        }
    }

}
