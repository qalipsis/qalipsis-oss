package io.evolue.api.steps

import io.evolue.api.context.StepContext
import io.evolue.api.sync.Slot

/**
 * Parent classes for reusable or polled clients.
 *
 * The implementations should continuously remove requests from the [request] slot and place the response
 * into the [response] slot, which is automatically returned to the output.
 *
 * When a context is required to configure the execution, it is placed into the [context] slot.
 *
 * [Slot] are used instead of [kotlinx.coroutines.channels.Channel]s to ensure that one response can be received
 * at a time from one request at the step layer (which might actually be different behind the scenes if the transport
 * protocol supports pipelining and multiplexing).
 *
 * @author Eric Jess√©
 *
 * @param RQ type of the requests generated by the client
 * @param RS type of the result received from the server
 * @param START_CTX type of the context used to start the client
 * @param CTX type of the context used to configure specific behaviors at execution time
 * @param STOP_CTX type of the context used to stop the client
 */
abstract class AbstractClient<RQ, RS, START_CTX : Any, CTX : Any, STOP_CTX : Any> {

    /**
     * Indicates if the client is open or closed.
     */
    abstract val isOpen: Boolean

    /**
     * Request for the client to receive the request to send.
     */
    protected val request = Slot<RQ>()

    /**
     * The client is single-threaded and can only receive one response at time.
     */
    protected val response = Slot<RS>()


    /**
     * Slot containing the context while being executed.
     */
    protected val context = Slot<CTX>()

    /**
     * Starts the consumption of [request].
     */
    abstract suspend fun open(startContext: START_CTX)

    /**
     * Stops the consumption of [request]. The method is idempotent: several calls lead to the same state.
     */
    abstract suspend fun close(stopContext: STOP_CTX)


    /**
     * Execution method for a client.
     */
    open suspend fun <I, O> execute(stepContext: StepContext<I, Pair<I, O>>, clientContext: CTX,
                               requestBuilder: suspend (I) -> RQ = { it as RQ },
                               responseBuilder: suspend (RS) -> O = { it as O }) {
        try {
            context.set(clientContext)
            val input = stepContext.input.receive()
            request.set(requestBuilder(input))
            stepContext.output.send(Pair(input, responseBuilder(response.get())))
        } finally {
            request.clear()
            context.clear()
            response.clear()
        }
    }

}